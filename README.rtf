{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;\red31\green136\blue139;\red0\green0\blue109;\red82\green0\blue103;
}
{\*\expandedcolortbl;;\csgenericrgb\c12157\c53333\c54510;\csgenericrgb\c0\c0\c42745;\csgenericrgb\c32157\c0\c40392;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 README file\
\
There is an interface called 
\f1\b MemoryOperations<K> 
\f0\b0 which includes the methods: \
	List<\cf2 K\cf0 > getDeck();\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1\b \cf3 	  void 
\f0\b0 \cf0 startGame(List<\cf2 K\cf0 > cards, 
\f1\b \cf3 int 
\f0\b0 \cf0 rows, 
\f1\b \cf3 int 
\f0\b0 \cf0 flipped);\
\

\f1\b \cf3 	  void 
\f0\b0 \cf0 guessCard(
\f1\b \cf3 int 
\f0\b0 \cf0 rowNumber, 
\f1\b \cf3 int 
\f0\b0 \cf0 cardIndex);\
\

\f1\b \cf3 	  boolean 
\f0\b0 \cf0 isGameOver();\
\
	  String getGameState();\
The class that implements the interface is called 
\f1\b MemoryModel
\f0\b0  which has the following fields:\
	
\f1\b \cf3 protected boolean \cf4 gameStarted
\f0\b0 \cf0 ;\

\f1\b \cf3 	protected 
\f0\b0 \cf0 ArrayList<ArrayList<Card>> 
\f1\b \cf4 board
\f0\b0 \cf0 ;\

\f1\b \cf3 	protected 
\f0\b0 \cf0 List<Card> 
\f1\b \cf4 cards
\f0\b0 \cf0 ;\

\f1\b \cf3 	protected 
\f0\b0 \cf0 List<Card> 
\f1\b \cf4 correctCards
\f0\b0 \cf0 ;\

\f1\b \cf3 	protected 
\f0\b0 \cf0 List<Card> 
\f1\b \cf4 guessed
\f0\b0 \cf0 ;\

\f1\b \cf3 	protected 
\f0\b0 \cf0 List<Card> 
\f1\b \cf4 notGuessed
\f0\b0 \cf0 ;\

\f1\b \cf3 	protected int \cf4 numOfRows
\f0\b0 \cf0 ;\
It keeps track of the state of the game by updating the game board and game states according to the user inputs. The user should provide a deck of valid cards, an appropriate number of rows they want in the game, as well as an appropriate number of cards being flipped. The model will set up the board accordingly and manage the game state.\
\
There is a 
\f1\b Card 
\f0\b0 class, which has the following fields:\

\f1\b \cf3 	private final int \cf4 value
\f0\b0 \cf0 ;\

\f1\b \cf3 	private final int \cf4 suit
\f0\b0 \cf0 ;\

\f1\b \cf3 	private final 
\f0\b0 \cf0 CardColor 
\f1\b \cf4 color
\f0\b0 \cf0 ;\

\f1\b \cf3 	private boolean \cf4 faceUp
\f0\b0 \cf0 ; 
\fs20 which represents whether the card is currently faced up or down in the game
\fs24 \

\f1\b \cf3 	private int \cf4 xPos
\f0\b0 \cf0 ; 
\fs20 which represents the x-coordinate of top left corner of the card in the game board
\fs24 \

\f1\b \cf3 	private int \cf4 yPos
\f0\b0 \cf0 ; 
\fs20 which represents the y-coordinate of top left corner of the card in the game board
\fs24 \
The card value ranges from 1 to 13, which represents the 13 types of value in a card deck, 10 representing Jack, 11 representing Queen, and 13 representing King. It has 4 suits - clubs, diamonds, hearts, or spades\
There is an enum 
\f1\b CardColor
\f0\b0  which consists of BLACK and RED\
\
\
\
\
\
}